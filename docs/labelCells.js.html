<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>labelCells.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/jkanche/scran.js" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Classes</h3><ul><li><a href="BuildLabelledReferenceResults.html">BuildLabelledReferenceResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="BuildLabelledReferenceResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="BuildLabelledReferenceResults.html#sharedFeatures">sharedFeatures</a></li></ul></li><li><a href="BuildNeighborSearchIndexResults.html">BuildNeighborSearchIndexResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="BuildNeighborSearchIndexResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="BuildNeighborSearchIndexResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="BuildNeighborSearchIndexResults.html#numberOfDims">numberOfDims</a></li></ul></li><li><a href="BuildSNNGraphResults.html">BuildSNNGraphResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="BuildSNNGraphResults.html#free">free</a></li></ul></li><li><a href="ClusterKmeansResults.html">ClusterKmeansResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#clusterCenters">clusterCenters</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#clusters">clusters</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#clusterSizes">clusterSizes</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#iterations">iterations</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#numberOfClusters">numberOfClusters</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#status">status</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#withinClusterSumSquares">withinClusterSumSquares</a></li></ul></li><li><a href="ClusterSNNGraphLeidenResults.html">ClusterSNNGraphLeidenResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClusterSNNGraphLeidenResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ClusterSNNGraphLeidenResults.html#membership">membership</a></li><li data-type='method' style='display: none;'><a href="ClusterSNNGraphLeidenResults.html#modularity">modularity</a></li></ul></li><li><a href="ClusterSNNGraphMultiLevelResults.html">ClusterSNNGraphMultiLevelResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClusterSNNGraphMultiLevelResults.html#best">best</a></li><li data-type='method' style='display: none;'><a href="ClusterSNNGraphMultiLevelResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ClusterSNNGraphMultiLevelResults.html#membership">membership</a></li><li data-type='method' style='display: none;'><a href="ClusterSNNGraphMultiLevelResults.html#modularity">modularity</a></li><li data-type='method' style='display: none;'><a href="ClusterSNNGraphMultiLevelResults.html#numberOfLevels">numberOfLevels</a></li></ul></li><li><a href="ClusterSNNGraphWalktrapResults.html">ClusterSNNGraphWalktrapResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClusterSNNGraphWalktrapResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ClusterSNNGraphWalktrapResults.html#membership">membership</a></li><li data-type='method' style='display: none;'><a href="ClusterSNNGraphWalktrapResults.html#modularity">modularity</a></li></ul></li><li><a href="FindNearestNeighborsResults.html">FindNearestNeighborsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#.unserialize">unserialize</a></li><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#serialize">serialize</a></li><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#size">size</a></li></ul></li><li><a href="H5Base.html">H5Base</a><ul class='methods'><li data-type='method' style='display: none;'><a href="H5Base.html#readAttribute">readAttribute</a></li><li data-type='method' style='display: none;'><a href="H5Base.html#writeAttribute">writeAttribute</a></li></ul></li><li><a href="H5DataSet.html">H5DataSet</a><ul class='methods'><li data-type='method' style='display: none;'><a href="H5DataSet.html#load">load</a></li><li data-type='method' style='display: none;'><a href="H5DataSet.html#readAttribute">readAttribute</a></li><li data-type='method' style='display: none;'><a href="H5DataSet.html#write">write</a></li><li data-type='method' style='display: none;'><a href="H5DataSet.html#writeAttribute">writeAttribute</a></li></ul></li><li><a href="H5File.html">H5File</a><ul class='methods'><li data-type='method' style='display: none;'><a href="H5File.html#createDataSet">createDataSet</a></li><li data-type='method' style='display: none;'><a href="H5File.html#createGroup">createGroup</a></li><li data-type='method' style='display: none;'><a href="H5File.html#open">open</a></li><li data-type='method' style='display: none;'><a href="H5File.html#readAttribute">readAttribute</a></li><li data-type='method' style='display: none;'><a href="H5File.html#writeAttribute">writeAttribute</a></li><li data-type='method' style='display: none;'><a href="H5File.html#writeDataSet">writeDataSet</a></li></ul></li><li><a href="H5Group.html">H5Group</a><ul class='methods'><li data-type='method' style='display: none;'><a href="H5Group.html#createDataSet">createDataSet</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#createGroup">createGroup</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#open">open</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#readAttribute">readAttribute</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#writeAttribute">writeAttribute</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#writeDataSet">writeDataSet</a></li></ul></li><li><a href="InitializeTSNEResults.html">InitializeTSNEResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="InitializeTSNEResults.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="InitializeTSNEResults.html#extractCoordinates">extractCoordinates</a></li><li data-type='method' style='display: none;'><a href="InitializeTSNEResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="InitializeTSNEResults.html#iterations">iterations</a></li><li data-type='method' style='display: none;'><a href="InitializeTSNEResults.html#numberOfCells">numberOfCells</a></li></ul></li><li><a href="InitializeUMAPResults.html">InitializeUMAPResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="InitializeUMAPResults.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="InitializeUMAPResults.html#currentEpoch">currentEpoch</a></li><li data-type='method' style='display: none;'><a href="InitializeUMAPResults.html#extractCoordinates">extractCoordinates</a></li><li data-type='method' style='display: none;'><a href="InitializeUMAPResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="InitializeUMAPResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="InitializeUMAPResults.html#totalEpochs">totalEpochs</a></li></ul></li><li><a href="IntegrateLabelledReferencesResults.html">IntegrateLabelledReferencesResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="IntegrateLabelledReferencesResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="IntegrateLabelledReferencesResults.html#numberOfReferences">numberOfReferences</a></li></ul></li><li><a href="LoadLabelledReferenceResults.html">LoadLabelledReferenceResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LoadLabelledReferenceResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="LoadLabelledReferenceResults.html#numberOfFeatures">numberOfFeatures</a></li><li data-type='method' style='display: none;'><a href="LoadLabelledReferenceResults.html#numberOfLabels">numberOfLabels</a></li><li data-type='method' style='display: none;'><a href="LoadLabelledReferenceResults.html#numberOfSamples">numberOfSamples</a></li></ul></li><li><a href="ModelGeneVarResults.html">ModelGeneVarResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ModelGeneVarResults.html#fitted">fitted</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVarResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVarResults.html#means">means</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVarResults.html#numberOfBlocks">numberOfBlocks</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVarResults.html#residuals">residuals</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVarResults.html#variances">variances</a></li></ul></li><li><a href="MultiMatrix.html">MultiMatrix</a><ul class='methods'><li data-type='method' style='display: none;'><a href="MultiMatrix.html#add">add</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#available">available</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#free">free</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#get">get</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#has">has</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#rename">rename</a></li></ul></li><li><a href="PerCellAdtQcFiltersResults.html">PerCellAdtQcFiltersResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PerCellAdtQcFiltersResults.html#discardDetected">discardDetected</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcFiltersResults.html#discardOverall">discardOverall</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcFiltersResults.html#discardSubsetTotals">discardSubsetTotals</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcFiltersResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcFiltersResults.html#numberOfSubsets">numberOfSubsets</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcFiltersResults.html#thresholdsDetected">thresholdsDetected</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcFiltersResults.html#thresholdsSubsetTotals">thresholdsSubsetTotals</a></li></ul></li><li><a href="PerCellAdtQcMetricsResults.html">PerCellAdtQcMetricsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#detected">detected</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#numberOfSubsets">numberOfSubsets</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#subsetTotals">subsetTotals</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#sums">sums</a></li></ul></li><li><a href="PerCellQCFiltersResults.html">PerCellQCFiltersResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PerCellQCFiltersResults.html#discardDetected">discardDetected</a></li><li data-type='method' style='display: none;'><a href="PerCellQCFiltersResults.html#discardOverall">discardOverall</a></li><li data-type='method' style='display: none;'><a href="PerCellQCFiltersResults.html#discardSubsetProportions">discardSubsetProportions</a></li><li data-type='method' style='display: none;'><a href="PerCellQCFiltersResults.html#discardSums">discardSums</a></li><li data-type='method' style='display: none;'><a href="PerCellQCFiltersResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="PerCellQCFiltersResults.html#numberOfSubsets">numberOfSubsets</a></li><li data-type='method' style='display: none;'><a href="PerCellQCFiltersResults.html#thresholdsDetected">thresholdsDetected</a></li><li data-type='method' style='display: none;'><a href="PerCellQCFiltersResults.html#thresholdsSubsetProportions">thresholdsSubsetProportions</a></li><li data-type='method' style='display: none;'><a href="PerCellQCFiltersResults.html#thresholdsSums">thresholdsSums</a></li></ul></li><li><a href="PerCellQCMetricsResults.html">PerCellQCMetricsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PerCellQCMetricsResults.html#detected">detected</a></li><li data-type='method' style='display: none;'><a href="PerCellQCMetricsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="PerCellQCMetricsResults.html#isProportion">isProportion</a></li><li data-type='method' style='display: none;'><a href="PerCellQCMetricsResults.html#numberOfSubsets">numberOfSubsets</a></li><li data-type='method' style='display: none;'><a href="PerCellQCMetricsResults.html#subsetProportions">subsetProportions</a></li><li data-type='method' style='display: none;'><a href="PerCellQCMetricsResults.html#sums">sums</a></li></ul></li><li><a href="RunPCAResults.html">RunPCAResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RunPCAResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RunPCAResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="RunPCAResults.html#numberOfPCs">numberOfPCs</a></li><li data-type='method' style='display: none;'><a href="RunPCAResults.html#principalComponents">principalComponents</a></li><li data-type='method' style='display: none;'><a href="RunPCAResults.html#totalVariance">totalVariance</a></li><li data-type='method' style='display: none;'><a href="RunPCAResults.html#varianceExplained">varianceExplained</a></li></ul></li><li><a href="ScoreMarkersResults.html">ScoreMarkersResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#auc">auc</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#cohen">cohen</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#deltaDetected">deltaDetected</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#detected">detected</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#lfc">lfc</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#means">means</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#numberOfBlocks">numberOfBlocks</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#numberOfGroups">numberOfGroups</a></li></ul></li><li><a href="ScranMatrix.html">ScranMatrix</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ScranMatrix.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#column">column</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#isSparse">isSparse</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#numberOfRows">numberOfRows</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#row">row</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#buildLabelledReference">buildLabelledReference</a></li><li><a href="global.html#buildNeighborSearchIndex">buildNeighborSearchIndex</a></li><li><a href="global.html#buildSNNGraph">buildSNNGraph</a></li><li><a href="global.html#cbind">cbind</a></li><li><a href="global.html#cbindWithNames">cbindWithNames</a></li><li><a href="global.html#chooseHVGs">chooseHVGs</a></li><li><a href="global.html#clusterKmeans">clusterKmeans</a></li><li><a href="global.html#clusterSNNGraph">clusterSNNGraph</a></li><li><a href="global.html#combineArrayCollections">combineArrayCollections</a></li><li><a href="global.html#computePerCellAdtQcFilters">computePerCellAdtQcFilters</a></li><li><a href="global.html#computePerCellAdtQcMetrics">computePerCellAdtQcMetrics</a></li><li><a href="global.html#computePerCellQCFilters">computePerCellQCFilters</a></li><li><a href="global.html#computePerCellQCMetrics">computePerCellQCMetrics</a></li><li><a href="global.html#convertBlock">convertBlock</a></li><li><a href="global.html#createBigUint64WasmArray">createBigUint64WasmArray</a></li><li><a href="global.html#createBlock">createBlock</a></li><li><a href="global.html#createFloat64WasmArray">createFloat64WasmArray</a></li><li><a href="global.html#createInt32WasmArray">createInt32WasmArray</a></li><li><a href="global.html#createNewHDF5File">createNewHDF5File</a></li><li><a href="global.html#createUint8WasmArray">createUint8WasmArray</a></li><li><a href="global.html#delayedArithmetic">delayedArithmetic</a></li><li><a href="global.html#delayedMath">delayedMath</a></li><li><a href="global.html#dropUnusedBlock">dropUnusedBlock</a></li><li><a href="global.html#emptyPerCellAdtQcMetricsResults">emptyPerCellAdtQcMetricsResults</a></li><li><a href="global.html#emptyPerCellQCMetricsResults">emptyPerCellQCMetricsResults</a></li><li><a href="global.html#extractHDF5ObjectNames">extractHDF5ObjectNames</a></li><li><a href="global.html#extractMatrixMarketDimensions">extractMatrixMarketDimensions</a></li><li><a href="global.html#fileExists">fileExists</a></li><li><a href="global.html#filterBlock">filterBlock</a></li><li><a href="global.html#filterCells">filterCells</a></li><li><a href="global.html#findNearestNeighbors">findNearestNeighbors</a></li><li><a href="global.html#free">free</a></li><li><a href="global.html#groupedSizeFactors">groupedSizeFactors</a></li><li><a href="global.html#guessFeatures">guessFeatures</a></li><li><a href="global.html#heapSize">heapSize</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeDenseMatrixFromDenseArray">initializeDenseMatrixFromDenseArray</a></li><li><a href="global.html#initializeSparseMatrixFromCompressedVectors">initializeSparseMatrixFromCompressedVectors</a></li><li><a href="global.html#initializeSparseMatrixFromDenseArray">initializeSparseMatrixFromDenseArray</a></li><li><a href="global.html#initializeSparseMatrixFromHDF5">initializeSparseMatrixFromHDF5</a></li><li><a href="global.html#initializeSparseMatrixFromMatrixMarket">initializeSparseMatrixFromMatrixMarket</a></li><li><a href="global.html#initializeTSNE">initializeTSNE</a></li><li><a href="global.html#initializeUMAP">initializeUMAP</a></li><li><a href="global.html#integrateCellLabels">integrateCellLabels</a></li><li><a href="global.html#integrateLabelledReferences">integrateLabelledReferences</a></li><li><a href="global.html#labelCells">labelCells</a></li><li><a href="global.html#listMito">listMito</a></li><li><a href="global.html#loadHDF5Dataset">loadHDF5Dataset</a></li><li><a href="global.html#loadLabelledReferenceFromBuffers">loadLabelledReferenceFromBuffers</a></li><li><a href="global.html#logNormCounts">logNormCounts</a></li><li><a href="global.html#maximumThreads">maximumThreads</a></li><li><a href="global.html#medianSizeFactors">medianSizeFactors</a></li><li><a href="global.html#mnnCorrect">mnnCorrect</a></li><li><a href="global.html#modelGeneVar">modelGeneVar</a></li><li><a href="global.html#perplexityToNeighbors">perplexityToNeighbors</a></li><li><a href="global.html#possibleCopy">possibleCopy</a></li><li><a href="global.html#quickAdtSizeFactors">quickAdtSizeFactors</a></li><li><a href="global.html#quickSliceArray">quickSliceArray</a></li><li><a href="global.html#rbind">rbind</a></li><li><a href="global.html#readFile">readFile</a></li><li><a href="global.html#removeFile">removeFile</a></li><li><a href="global.html#runPCA">runPCA</a></li><li><a href="global.html#runTSNE">runTSNE</a></li><li><a href="global.html#runUMAP">runUMAP</a></li><li><a href="global.html#scaleByNeighbors">scaleByNeighbors</a></li><li><a href="global.html#scoreMarkers">scoreMarkers</a></li><li><a href="global.html#splitArrayCollection">splitArrayCollection</a></li><li><a href="global.html#splitByFactor">splitByFactor</a></li><li><a href="global.html#splitRows">splitRows</a></li><li><a href="global.html#subsetArrayCollection">subsetArrayCollection</a></li><li><a href="global.html#subsetBlock">subsetBlock</a></li><li><a href="global.html#subsetColumns">subsetColumns</a></li><li><a href="global.html#subsetRows">subsetRows</a></li><li><a href="global.html#terminate">terminate</a></li><li><a href="global.html#transpose">transpose</a></li><li><a href="global.html#updateRowIdentities">updateRowIdentities</a></li><li><a href="global.html#validateArrayCollection">validateArrayCollection</a></li><li><a href="global.html#wasmArraySpace">wasmArraySpace</a></li><li><a href="global.html#writeFile">writeFile</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">labelCells.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as gc from "./gc.js";
import * as wasm from "./wasm.js";
import * as utils from "./utils.js";
import { ScranMatrix } from "./ScranMatrix.js";
import * as wa from "wasmarrays.js";

/**
 * Wrapper around a labelled reference dataset on the Wasm heap, typically produced by {@linkcode loadLabelledReferenceFromBuffers}.
 * @hideconstructor
 */
class LoadLabelledReferenceResults {
    #id;
    #reference;

    constructor(id, raw) {
        this.#id = id;
        this.#reference = raw;
        return;
    }

    // Internal use only, not documented.
    get reference() {
        return this.#reference;
    }

    /**
     * @return {number} Number of samples in this dataset.
     */
    numberOfSamples() {
        return this.#reference.num_samples();
    }

    /**
     * @return {number} Number of features in this dataset.
     */
    numberOfFeatures() {
        return this.#reference.num_features();
    }

    /**
     * @return {number} Number of labels in this dataset.
     */
    numberOfLabels() {
        return this.#reference.num_labels();
    }

    /**
     * @return Frees the memory allocated on the Wasm heap for this object.
     * This invalidates this object and all references to it.
     */
    free() {
        if (this.#reference !== null) {
            gc.release(this.#id);
            this.#reference = null;
        }
    }
}

/**
 * Load a reference dataset for annotation.
 * 
 * @param {Uint8Array} ranks - Buffer containing the Gzipped CSV file containing a matrix of ranks.
 * Each line corresponds to a sample and contains a comma-separated vector of ranks across all features.
 * All lines should contain the same number of entries.
 * This is effectively a row-major matrix where rows are samples and columns are features.
 * (Advanced users may note that this is transposed in C++.) 
 * @param {Uint8Array} markers - Buffer containing the Gzipped GMT file containing the markers for each pairwise comparison between labels.
 * For `markers`, the GMT format is a tab-separated file with possibly variable numbers of fields for each line.
 * Each line corresponds to a pairwise comparison between labels, defined by the first two fields.
 * The remaining fields should contain indices of marker features (referring to columns of `matrix`) that are upregulated in the first label when compared to the second.
 * Markers should be sorted in order of decreasing strength.
 * @param {Uint8Array} labels - Buffer containing the Gzipped text file containing the label for each sample.
 * Each line should contain an integer representing a particular label, from `[0, N)` where `N` is the number of unique labels.
 * The number of lines should be equal to the number of rows in `matrix`.
 * The actual names of the labels are usually held elsewhere.
 * 
 * @return {LoadLabelledReferenceResults} Object containing the reference dataset.
 */
export function loadLabelledReferenceFromBuffers(ranks, markers, labels) {
    var output;
    var matbuf;
    var markbuf;
    var labbuf;

    try {
        matbuf = utils.wasmifyArray(ranks, "Uint8WasmArray");
        markbuf = utils.wasmifyArray(markers, "Uint8WasmArray");
        labbuf = utils.wasmifyArray(labels, "Uint8WasmArray");
        output = gc.call(
            module => module.load_singlepp_reference(labbuf.offset, labbuf.length, markbuf.offset, markbuf.length, matbuf.offset, matbuf.length),
            LoadLabelledReferenceResults
        );

    } catch (e) {
        utils.free(output);
        throw e;

    } finally {
        utils.free(matbuf);
        utils.free(markbuf);
        utils.free(labbuf);
    }

    return output;
}

/**
 * Wrapper around a built labelled reference dataset on the Wasm heap, typically produced by {@linkcode buildLabelledReference}.
 * @hideconstructor
 */
class BuildLabelledReferenceResults {
    #id;
    #reference;

    constructor(id, raw) {
        this.#id = id;
        this.#reference = raw;
        return;
    }

    // internal use only.
    get reference() {
        return this.#reference;
    }

    /**
     * @return {number} Number of shared features between the test and reference datasets.
     */
    sharedFeatures() {
        return this.#reference.shared_features();
    }

    /**
     * @return Frees the memory allocated on the Wasm heap for this object.
     * This invalidates this object and all references to it.
     */
    free() {
        if (this.#reference !== null) {
            gc.release(this.#id);
            this.#reference = null;
        }
    }
}

function create_feature_availability(features, mat_id_buffer) {
    let mat_id_array = mat_id_buffer.array();
    let available = {};
    let counter = 0;
    features.forEach(y => {
        available[y] = counter;
        mat_id_array[counter] = counter;
        counter++;
    });
    return available;
}

function convert_reference_features(referenceFeatures, available, ref_id_buffer) {  
    let ref_id_array = ref_id_buffer.array();
    let counter = Object.keys(available).length;
    referenceFeatures.forEach((y, i) => {
        if (y in available) {
            ref_id_array[i] = available[y];
        } else {
            ref_id_array[i] = counter;
            counter++;
        }
    });
    return;
}

/**
 * Build the reference dataset for annotation.
 * The build process involves harmonizing the identities of the features available in the test dataset compared to the reference.
 * Specifically, a feature must be present in both datasets in order to be retained. 
 * Of those features in the intersection, only the `top` markers from each pairwise comparison are ultimately used for classification.
 *
 * Needless to say, `features` should match up to the rows of the {@linkplain ScranMatrix} that is actually used for annotation in {@linkcode labelCells}.
 *
 * @param {Array} features - An array of feature identifiers (usually strings) of length equal to the number of rows in the test matrix.
 * Each entry should contain the identifier for the corresponding row of the test matrix.
 * @param {LoadLabelledReferenceResults} loaded - A reference dataset, typically loaded with {@linkcode loadLabelledReferenceFromBuffers}.
 * @param {Array} referenceFeatures - An array of feature identifiers (usually strings) of length equal to the number of features in `reference`.
 * This is expected to exhibit some overlap with those in `features`.
 * @param {object} [options] - Optional parameters.
 * @param {number} [options.top=20] - Number of top marker features to use.
 * These features are taken from each pairwise comparison between labels.
 * @param {?number} [options.numberOfThreads=null] - Number of threads to use.
 * If `null`, defaults to {@linkcode maximumThreads}.
 *
 * @return {BuildLabelledReferenceResults} Object containing the built reference dataset.
 */
export function buildLabelledReference(features, loaded, referenceFeatures, { top = 20, numberOfThreads = null } = {}) {
    var mat_id_buffer;
    var ref_id_buffer;
    var output;
    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);

    try {
        var nfeat = features.length;
        mat_id_buffer = utils.createInt32WasmArray(nfeat);
        ref_id_buffer = utils.createInt32WasmArray(loaded.numberOfFeatures());
        if (referenceFeatures.length != ref_id_buffer.length) {
            throw new Error("length of 'referenceFeatures' should be equal to the number of features in 'reference'");
        }

        let available = create_feature_availability(features, mat_id_buffer);
        convert_reference_features(referenceFeatures, available, ref_id_buffer);

        output = gc.call(
            module => module.build_singlepp_reference(nfeat, mat_id_buffer.offset, loaded.reference, ref_id_buffer.offset, top, nthreads),
            BuildLabelledReferenceResults
        );

        output.expectedNumberOfFeatures = nfeat;

    } catch (e) {
        utils.free(output);
        throw e;

    } finally {
        utils.free(mat_id_buffer);
        utils.free(ref_id_buffer);
    }

    return output;
}

function label_cells(x, expectedNumberOfFeatures, buffer, numberOfFeatures, numberOfCells, FUN, msg) {
    var output = null;
    var matbuf;
    var tempmat;
    var tempbuf;
    let use_buffer = (buffer instanceof wa.Int32WasmArray);

    try {
        let target;
        if (x instanceof ScranMatrix) {
            target = x.matrix;
        } else if (x instanceof wa.Float64WasmArray) {
            if (x.length !== numberOfFeatures * numberOfCells) {
                throw new Error("length of 'x' must be equal to the product of 'numberOfFeatures' and 'numberOfCells'");
            }

            // This will either create a cheap view, or it'll clone
            // 'x' into the appropriate memory space.
            matbuf = utils.wasmifyArray(x, null);
            tempmat = gc.call(
                module => module.initialize_dense_matrix(numberOfFeatures, numberOfCells, matbuf.offset, "Float64Array"),
                ScranMatrix
            );
            target = tempmat.matrix;

        } else {
            throw new Error("unknown type for 'x'");
        }

        if (target.nrow() != expectedNumberOfFeatures) {
            throw new Error("number of rows in 'x' should be equal to length of 'features' used to build '" + msg + "'");
        }

        let ptr;
        if (!use_buffer) {
            tempbuf = utils.createInt32WasmArray(target.ncol());
            ptr = tempbuf.offset;
        } else {
            ptr = buffer.offset;
        }

        FUN(target, ptr);
        if (!use_buffer) {
            output = tempbuf.slice();
        }

    } finally {
        utils.free(matbuf);
        utils.free(tempmat);
        utils.free(tempbuf);
    }

    return output;
}

/**
 * Label cells based on similarity in expression to a reference dataset.
 *
 * @param {(ScranMatrix|Float64WasmArray)} x - The count matrix, or log-normalized matrix, containing features in the rows and cells in the columns.
 * If a Float64WasmArray is supplied, it is assumed to contain a column-major dense matrix.
 * @param {BuildLabelledReferenceResults} reference - A built reference dataset, typically generated by {@linkcode buildLabelledReference}.
 * @param {object} [options] - Optional parameters.
 * @param {?Int32WasmArray} [options.buffer=null] - An existing buffer to store the output labels, of length equal to the number of columns in `x`.
 * @param {?number} [options.numberOfFeatures=null] - Number of features, used when `x` is a Float64WasmArray.
 * @param {?number} [options.numberOfCells=null] - Number of cells, used when `x` is a Float64WasmArray.
 * @param {number} [options.quantile=0.8] - Quantile on the correlations to use to compute the score for each label.
 * @param {?number} [options.numberOfThreads=null] - Number of threads to use.
 * If `null`, defaults to {@linkcode maximumThreads}.
 *
 * @return {Int32Array} Array containing the labels for each cell in `x`.
 *
 * If `buffer` was supplied, the returned array is a view into it.
 * Note that this may be invalidated on the next allocation on the Wasm heap.
 */
export function labelCells(x, reference, { buffer = null, numberOfFeatures = null, numberOfCells = null, quantile = 0.8, numberOfThreads = null } = {}) {
    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);
    let FUN = (target, ptr) => {
        wasm.call(module => module.run_singlepp(target, reference.reference, quantile, ptr, nthreads));
    };

    let output = label_cells(x, reference.expectedNumberOfFeatures, buffer, numberOfFeatures, numberOfCells, FUN, "reference");

    // This is done as the final step to avoid invalidation upon any touching
    // of the Wasm heap, anywhere... even upon freeing.
    if (output === null) {
        output = buffer.array();
    }

    return output;
}

/**
 * Wrapper around integrated reference datasets on the Wasm heap, typically produced by {@linkcode integrateLabelledReferences}.
 * @hideconstructor
 */
class IntegrateLabelledReferencesResults {
    #id;
    #integrated;

    constructor(id, raw) {
        this.#id = id;
        this.#integrated = raw;
        return;
    }

    // Internal use only, not documented.
    get integrated() {
        return this.#integrated;
    }

    /**
     * @return {number} Number of reference datasets.
     */
    numberOfReferences() {
        return this.#integrated.num_references();
    }

    /**
     * @return Frees the memory allocated on the Wasm heap for this object.
     * This invalidates this object and all references to it.
     */
    free() {
        if (this.#integrated !== null) {
            gc.release(this.#id);
            this.#integrated = null;
        }
    }
}

/**
 * Integrate multiple reference datasets.
 *
 * @param {Array} features - An array of feature identifiers (usually strings) of length equal to the number of rows in the test matrix.
 * Each entry should contain the identifier for the corresponding row of the test matrix.
 * @param {Array} loaded - Array of {@linkplain LabelledReference} objects, typically created with {@linkcode loadLabelledReferenceFromBuffers}.
 * @param {Array} referenceFeatures - Array of length equal to `loaded`, 
 * containing arrays of feature identifiers (usually strings) of length equal to the number of features the corresponding entry of `loaded`.
 * This is expected to exhibit some overlap with those in `features`.
 * @param {Array} reference - Array of {@linkplain BuildLabelledReferenceResults} objects, typically generated by {@linkcode buildLabelledReference}.
 * This should have length equal to that of `loaded`.
 * @param {object} [options] - Optional parameters.
 * @param {?number} [options.numberOfThreads=null] - Number of threads to use.
 * If `null`, defaults to {@linkcode maximumThreads}.
 *
 * @return {IntegrateLabelledReferencesResults} Object containing the integrated references.
 */
export function integrateLabelledReferences(features, loaded, referenceFeatures, built, { numberOfThreads = null } = {}) {
    let id_arr;
    let loaded_arr2;
    let ref_arr2;
    let built_arr2;
    let output;
    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);

    // Checking the inputs.
    let nrefs = loaded.length;
    if (referenceFeatures.length != nrefs) {
        throw new Error("'loaded' and 'referenceFeatures' should be of the same length");
    }
    if (built.length != nrefs) {
        throw new Error("'loaded' and 'built' should be of the same length");
    }
    for (var i = 0; i &lt; nrefs; i++) {
        if (loaded[i].numberOfFeatures() != referenceFeatures[i].length) {
            throw new Error("length of each 'referenceFeatures' should be equal to the number of features in the corresponding 'loaded'");
        }
    }

    let ref_arr = new Array(nrefs);

    try {
        id_arr = utils.createInt32WasmArray(features.length);
        let available = create_feature_availability(features, id_arr);

        loaded_arr2 = utils.createBigUint64WasmArray(nrefs);
        let la2 = loaded_arr2.array();
        for (var i = 0; i &lt; nrefs; i++) {
            la2[i] = BigInt(loaded[i].reference.$$.ptr);
        }

        ref_arr2 = utils.createBigUint64WasmArray(nrefs);
        let ra2 = ref_arr2.array();
        for (var i = 0; i &lt; nrefs; i++) {
            let current = referenceFeatures[i];
            if (current instanceof wa.Int32WasmArray) {
                ra2[i] = BigInt(current.offset);
            } else {
                ref_arr[i] = utils.createInt32WasmArray(current.length);
                convert_reference_features(current, available, ref_arr[i]);
                ra2[i] = BigInt(ref_arr[i].offset);
            }
        }

        built_arr2 = utils.createBigUint64WasmArray(nrefs);
        let ba2 = built_arr2.array();
        for (var i = 0; i &lt; nrefs; i++) {
            ba2[i] = BigInt(built[i].reference.$$.ptr);
        }
        
        output = gc.call(
            module => module.integrate_singlepp_references(
                features.length,
                id_arr.offset,
                nrefs,
                loaded_arr2.offset,
                ref_arr2.offset,
                built_arr2.offset,
                nthreads
            ),
            IntegrateLabelledReferencesResults
        );

        output.expectedNumberOfFeatures = features.length;

    } catch (e) {
        utils.free(output);
        throw e;

    } finally {
        utils.free(id_arr);
        utils.free(loaded_arr2);
        utils.free(built_arr2);
        utils.free(ref_arr2);
        for (const x of ref_arr) {
            utils.free(x);
        }
    }

    return output;
}

/**
 * Label cells based on similarity in expression to a reference dataset.
 *
 * @param {(ScranMatrix|Float64WasmArray)} x - The count matrix, or log-normalized matrix, containing features in the rows and cells in the columns.
 * If a Float64WasmArray is supplied, it is assumed to contain a column-major dense matrix.
 * @param {IntegratedLabelledReferences} integrated - An integrated set of reference datasets, typically generated by {@linkcode integrateLabelledReferences}.
 * @param {Array} assigned - An array of length equal to the number of references in `integrated`.
 * This should contain the result of classification of `x` with each individual reference via {@linkcode labelCells}.
 * Each element should be an Array, TypedArray or Int32WasmArray of length equal to the number of cells in `x`.
 * @param {object} [options] - Optional parameters.
 * @param {?Int32WasmArray} [options.buffer=null] - An existing buffer to store the output labels, of length equal to the number of columns in `x`.
 * @param {?number} [options.numberOfFeatures=null] - Number of features, used when `x` is a Float64WasmArray.
 * @param {?number} [options.numberOfCells=null] - Number of cells, used when `x` is a Float64WasmArray.
 * @param {number} [options.quantile=0.8] - Quantile on the correlations to use to compute the score for each label.
 * @param {?number} [options.numberOfThreads=null] - Number of threads to use.
 * If `null`, defaults to {@linkcode maximumThreads}.
 *
 * @return {Int32Array} Array containing the best reference for each cell in `x`.
 *
 * If `buffer` was supplied, the returned array is a view into it.
 * Note that this may be invalidated on the next allocation on the Wasm heap.
 */
export function integrateCellLabels(x, assigned, integrated, { buffer = null, numberOfFeatures = null, numberOfCells = null, quantile = 0.8, numberOfThreads = null } = {}) { 
    let nrefs = integrated.numberOfReferences();
    if (assigned.length != nrefs) {
        throw new Error("length of 'assigned' should be equal to the number of references in 'integrated'");
    }

    let output;
    let aptrs;
    let assigned_arrs = new Array(nrefs);
    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);

    try {
        aptrs = utils.createBigUint64WasmArray(nrefs);
        let aptrs_arr = aptrs.array();
        for (var i = 0; i &lt; assigned.length; i++) {
            let current = assigned[i];

            let fail = false;
            if (x instanceof ScranMatrix) {
                if (current.length != x.numberOfColumns()) {
                    fail = true;
                }
            } else if (current.length != numberOfCells) {
                fail = true;
            }
            if (fail) {
                throw new Error("length of each element 'assigned' should be equal to number of columns in 'x'");
            }

            assigned_arrs[i] = utils.wasmifyArray(current, "Int32WasmArray");
            aptrs_arr[i] = BigInt(assigned_arrs[i].offset);
        }
    
        let FUN = (target, ptr) => {
            wasm.call(module => module.integrate_singlepp(target, aptrs_arr.offset, integrated.integrated, quantile, ptr, nthreads));
        };
        output = label_cells(x, integrated.expectedNumberOfFeatures, buffer, numberOfFeatures, numberOfCells, FUN, "integrated");

    } finally{
        utils.free(aptrs);
        for (const x of assigned_arrs) {
            utils.free(x);
        }
    }

    // This is done as the final step to avoid invalidation upon any touching
    // of the Wasm heap, anywhere... even upon freeing.
    if (output === null) {
        output = buffer.array();
    }

    return output;
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Wed Aug 17 2022 16:49:01 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
