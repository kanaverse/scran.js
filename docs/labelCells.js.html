<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>labelCells.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/jkanche/scran.js" target="_blank" class="menu-item" id="repository" >Github repo</a></h2><h3>Classes</h3><ul><li><a href="AggregateAcrossCellsResults.html">AggregateAcrossCellsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="AggregateAcrossCellsResults.html#allDetected">allDetected</a></li><li data-type='method' style='display: none;'><a href="AggregateAcrossCellsResults.html#allSums">allSums</a></li><li data-type='method' style='display: none;'><a href="AggregateAcrossCellsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="AggregateAcrossCellsResults.html#groupDetected">groupDetected</a></li><li data-type='method' style='display: none;'><a href="AggregateAcrossCellsResults.html#groupSums">groupSums</a></li><li data-type='method' style='display: none;'><a href="AggregateAcrossCellsResults.html#numberOfGenes">numberOfGenes</a></li><li data-type='method' style='display: none;'><a href="AggregateAcrossCellsResults.html#numberOfGroups">numberOfGroups</a></li></ul></li><li><a href="BuildNeighborSearchIndexResults.html">BuildNeighborSearchIndexResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="BuildNeighborSearchIndexResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="BuildNeighborSearchIndexResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="BuildNeighborSearchIndexResults.html#numberOfDims">numberOfDims</a></li></ul></li><li><a href="BuildSnnGraphResults.html">BuildSnnGraphResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="BuildSnnGraphResults.html#free">free</a></li></ul></li><li><a href="ClusterKmeansResults.html">ClusterKmeansResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#centers">centers</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#clusters">clusters</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#iterations">iterations</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#numberOfClusters">numberOfClusters</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#sizes">sizes</a></li><li data-type='method' style='display: none;'><a href="ClusterKmeansResults.html#status">status</a></li></ul></li><li><a href="ClusterLeidenResults.html">ClusterLeidenResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClusterLeidenResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ClusterLeidenResults.html#membership">membership</a></li><li data-type='method' style='display: none;'><a href="ClusterLeidenResults.html#modularity">modularity</a></li></ul></li><li><a href="ClusterMultilevelResults.html">ClusterMultilevelResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClusterMultilevelResults.html#bestLevel">bestLevel</a></li><li data-type='method' style='display: none;'><a href="ClusterMultilevelResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ClusterMultilevelResults.html#membership">membership</a></li><li data-type='method' style='display: none;'><a href="ClusterMultilevelResults.html#modularity">modularity</a></li><li data-type='method' style='display: none;'><a href="ClusterMultilevelResults.html#numberOfLevels">numberOfLevels</a></li></ul></li><li><a href="ClusterWalktrapResults.html">ClusterWalktrapResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ClusterWalktrapResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ClusterWalktrapResults.html#membership">membership</a></li><li data-type='method' style='display: none;'><a href="ClusterWalktrapResults.html#modularity">modularity</a></li><li data-type='method' style='display: none;'><a href="ClusterWalktrapResults.html#numberOfMergeSteps">numberOfMergeSteps</a></li></ul></li><li><a href="FindNearestNeighborsResults.html">FindNearestNeighborsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#.unserialize">unserialize</a></li><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#numberOfNeighbors">numberOfNeighbors</a></li><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#serialize">serialize</a></li><li data-type='method' style='display: none;'><a href="FindNearestNeighborsResults.html#size">size</a></li></ul></li><li><a href="H5Base.html">H5Base</a><ul class='methods'><li data-type='method' style='display: none;'><a href="H5Base.html#readAttribute">readAttribute</a></li><li data-type='method' style='display: none;'><a href="H5Base.html#writeAttribute">writeAttribute</a></li></ul></li><li><a href="H5CompoundType.html">H5CompoundType</a></li><li><a href="H5DataSet.html">H5DataSet</a><ul class='methods'><li data-type='method' style='display: none;'><a href="H5DataSet.html#readAttribute">readAttribute</a></li><li data-type='method' style='display: none;'><a href="H5DataSet.html#write">write</a></li><li data-type='method' style='display: none;'><a href="H5DataSet.html#writeAttribute">writeAttribute</a></li></ul></li><li><a href="H5EnumType.html">H5EnumType</a></li><li><a href="H5File.html">H5File</a><ul class='methods'><li data-type='method' style='display: none;'><a href="H5File.html#createDataSet">createDataSet</a></li><li data-type='method' style='display: none;'><a href="H5File.html#createGroup">createGroup</a></li><li data-type='method' style='display: none;'><a href="H5File.html#open">open</a></li><li data-type='method' style='display: none;'><a href="H5File.html#readAttribute">readAttribute</a></li><li data-type='method' style='display: none;'><a href="H5File.html#writeAttribute">writeAttribute</a></li><li data-type='method' style='display: none;'><a href="H5File.html#writeDataSet">writeDataSet</a></li></ul></li><li><a href="H5Group.html">H5Group</a><ul class='methods'><li data-type='method' style='display: none;'><a href="H5Group.html#createDataSet">createDataSet</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#createGroup">createGroup</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#open">open</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#readAttribute">readAttribute</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#writeAttribute">writeAttribute</a></li><li data-type='method' style='display: none;'><a href="H5Group.html#writeDataSet">writeDataSet</a></li></ul></li><li><a href="H5StringType.html">H5StringType</a></li><li><a href="IntegratedLabelCellsReferences.html">IntegratedLabelCellsReferences</a><ul class='methods'><li data-type='method' style='display: none;'><a href="IntegratedLabelCellsReferences.html#free">free</a></li><li data-type='method' style='display: none;'><a href="IntegratedLabelCellsReferences.html#numberOfReferences">numberOfReferences</a></li></ul></li><li><a href="IntegrateLabelCellsResults.html">IntegrateLabelCellsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="IntegrateLabelCellsResults.html#delta">delta</a></li><li data-type='method' style='display: none;'><a href="IntegrateLabelCellsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="IntegrateLabelCellsResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="IntegrateLabelCellsResults.html#numberOfReferences">numberOfReferences</a></li><li data-type='method' style='display: none;'><a href="IntegrateLabelCellsResults.html#predicted">predicted</a></li><li data-type='method' style='display: none;'><a href="IntegrateLabelCellsResults.html#scoreForCell">scoreForCell</a></li><li data-type='method' style='display: none;'><a href="IntegrateLabelCellsResults.html#scoreForReference">scoreForReference</a></li></ul></li><li><a href="LabelCellsResults.html">LabelCellsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LabelCellsResults.html#delta">delta</a></li><li data-type='method' style='display: none;'><a href="LabelCellsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="LabelCellsResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="LabelCellsResults.html#numberOfLabels">numberOfLabels</a></li><li data-type='method' style='display: none;'><a href="LabelCellsResults.html#predicted">predicted</a></li><li data-type='method' style='display: none;'><a href="LabelCellsResults.html#scoreForCell">scoreForCell</a></li><li data-type='method' style='display: none;'><a href="LabelCellsResults.html#scoreForLabel">scoreForLabel</a></li></ul></li><li><a href="LoadedLabelCellsReference.html">LoadedLabelCellsReference</a><ul class='methods'><li data-type='method' style='display: none;'><a href="LoadedLabelCellsReference.html#free">free</a></li><li data-type='method' style='display: none;'><a href="LoadedLabelCellsReference.html#numberOfFeatures">numberOfFeatures</a></li><li data-type='method' style='display: none;'><a href="LoadedLabelCellsReference.html#numberOfLabels">numberOfLabels</a></li><li data-type='method' style='display: none;'><a href="LoadedLabelCellsReference.html#numberOfSamples">numberOfSamples</a></li></ul></li><li><a href="ModelGeneVariancesResults.html">ModelGeneVariancesResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ModelGeneVariancesResults.html#fitted">fitted</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVariancesResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVariancesResults.html#isBlocked">isBlocked</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVariancesResults.html#means">means</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVariancesResults.html#numberOfBlocks">numberOfBlocks</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVariancesResults.html#residuals">residuals</a></li><li data-type='method' style='display: none;'><a href="ModelGeneVariancesResults.html#variances">variances</a></li></ul></li><li><a href="MultiMatrix.html">MultiMatrix</a><ul class='methods'><li data-type='method' style='display: none;'><a href="MultiMatrix.html#add">add</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#available">available</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#free">free</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#get">get</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#has">has</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#remove">remove</a></li><li data-type='method' style='display: none;'><a href="MultiMatrix.html#rename">rename</a></li></ul></li><li><a href="PerCellAdtQcMetricsResults.html">PerCellAdtQcMetricsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#detected">detected</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#numberOfSubsets">numberOfSubsets</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#subsetSum">subsetSum</a></li><li data-type='method' style='display: none;'><a href="PerCellAdtQcMetricsResults.html#sum">sum</a></li></ul></li><li><a href="PerCellCrisprQcMetricsResults.html">PerCellCrisprQcMetricsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PerCellCrisprQcMetricsResults.html#detected">detected</a></li><li data-type='method' style='display: none;'><a href="PerCellCrisprQcMetricsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="PerCellCrisprQcMetricsResults.html#maxIndex">maxIndex</a></li><li data-type='method' style='display: none;'><a href="PerCellCrisprQcMetricsResults.html#maxProportion">maxProportion</a></li><li data-type='method' style='display: none;'><a href="PerCellCrisprQcMetricsResults.html#maxValue">maxValue</a></li><li data-type='method' style='display: none;'><a href="PerCellCrisprQcMetricsResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="PerCellCrisprQcMetricsResults.html#sum">sum</a></li></ul></li><li><a href="PerCellRnaQcMetricsResults.html">PerCellRnaQcMetricsResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="PerCellRnaQcMetricsResults.html#detected">detected</a></li><li data-type='method' style='display: none;'><a href="PerCellRnaQcMetricsResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="PerCellRnaQcMetricsResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="PerCellRnaQcMetricsResults.html#numberOfSubsets">numberOfSubsets</a></li><li data-type='method' style='display: none;'><a href="PerCellRnaQcMetricsResults.html#subsetProportion">subsetProportion</a></li><li data-type='method' style='display: none;'><a href="PerCellRnaQcMetricsResults.html#sum">sum</a></li></ul></li><li><a href="RdsBooleanVector.html">RdsBooleanVector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsBooleanVector.html#attribute">attribute</a></li><li data-type='method' style='display: none;'><a href="RdsBooleanVector.html#attributeNames">attributeNames</a></li><li data-type='method' style='display: none;'><a href="RdsBooleanVector.html#findAttribute">findAttribute</a></li><li data-type='method' style='display: none;'><a href="RdsBooleanVector.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsBooleanVector.html#length">length</a></li><li data-type='method' style='display: none;'><a href="RdsBooleanVector.html#type">type</a></li><li data-type='method' style='display: none;'><a href="RdsBooleanVector.html#values">values</a></li></ul></li><li><a href="RdsDetails.html">RdsDetails</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsDetails.html#formatVersion">formatVersion</a></li><li data-type='method' style='display: none;'><a href="RdsDetails.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsDetails.html#readerVersion">readerVersion</a></li><li data-type='method' style='display: none;'><a href="RdsDetails.html#value">value</a></li><li data-type='method' style='display: none;'><a href="RdsDetails.html#writerVersion">writerVersion</a></li></ul></li><li><a href="RdsDoubleVector.html">RdsDoubleVector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsDoubleVector.html#attribute">attribute</a></li><li data-type='method' style='display: none;'><a href="RdsDoubleVector.html#attributeNames">attributeNames</a></li><li data-type='method' style='display: none;'><a href="RdsDoubleVector.html#findAttribute">findAttribute</a></li><li data-type='method' style='display: none;'><a href="RdsDoubleVector.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsDoubleVector.html#length">length</a></li><li data-type='method' style='display: none;'><a href="RdsDoubleVector.html#type">type</a></li><li data-type='method' style='display: none;'><a href="RdsDoubleVector.html#values">values</a></li></ul></li><li><a href="RdsGenericVector.html">RdsGenericVector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsGenericVector.html#attribute">attribute</a></li><li data-type='method' style='display: none;'><a href="RdsGenericVector.html#attributeNames">attributeNames</a></li><li data-type='method' style='display: none;'><a href="RdsGenericVector.html#findAttribute">findAttribute</a></li><li data-type='method' style='display: none;'><a href="RdsGenericVector.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsGenericVector.html#length">length</a></li><li data-type='method' style='display: none;'><a href="RdsGenericVector.html#load">load</a></li><li data-type='method' style='display: none;'><a href="RdsGenericVector.html#type">type</a></li></ul></li><li><a href="RdsIntegerVector.html">RdsIntegerVector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsIntegerVector.html#attribute">attribute</a></li><li data-type='method' style='display: none;'><a href="RdsIntegerVector.html#attributeNames">attributeNames</a></li><li data-type='method' style='display: none;'><a href="RdsIntegerVector.html#findAttribute">findAttribute</a></li><li data-type='method' style='display: none;'><a href="RdsIntegerVector.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsIntegerVector.html#length">length</a></li><li data-type='method' style='display: none;'><a href="RdsIntegerVector.html#type">type</a></li><li data-type='method' style='display: none;'><a href="RdsIntegerVector.html#values">values</a></li></ul></li><li><a href="RdsNull.html">RdsNull</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsNull.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsNull.html#type">type</a></li></ul></li><li><a href="RdsObject.html">RdsObject</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsObject.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsObject.html#type">type</a></li></ul></li><li><a href="RdsS4Object.html">RdsS4Object</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsS4Object.html#attribute">attribute</a></li><li data-type='method' style='display: none;'><a href="RdsS4Object.html#attributeNames">attributeNames</a></li><li data-type='method' style='display: none;'><a href="RdsS4Object.html#className">className</a></li><li data-type='method' style='display: none;'><a href="RdsS4Object.html#findAttribute">findAttribute</a></li><li data-type='method' style='display: none;'><a href="RdsS4Object.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsS4Object.html#packageName">packageName</a></li><li data-type='method' style='display: none;'><a href="RdsS4Object.html#type">type</a></li></ul></li><li><a href="RdsStringVector.html">RdsStringVector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsStringVector.html#attribute">attribute</a></li><li data-type='method' style='display: none;'><a href="RdsStringVector.html#attributeNames">attributeNames</a></li><li data-type='method' style='display: none;'><a href="RdsStringVector.html#findAttribute">findAttribute</a></li><li data-type='method' style='display: none;'><a href="RdsStringVector.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsStringVector.html#length">length</a></li><li data-type='method' style='display: none;'><a href="RdsStringVector.html#type">type</a></li><li data-type='method' style='display: none;'><a href="RdsStringVector.html#values">values</a></li></ul></li><li><a href="RdsVector.html">RdsVector</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RdsVector.html#attribute">attribute</a></li><li data-type='method' style='display: none;'><a href="RdsVector.html#attributeNames">attributeNames</a></li><li data-type='method' style='display: none;'><a href="RdsVector.html#findAttribute">findAttribute</a></li><li data-type='method' style='display: none;'><a href="RdsVector.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RdsVector.html#length">length</a></li><li data-type='method' style='display: none;'><a href="RdsVector.html#type">type</a></li></ul></li><li><a href="RunPcaResults.html">RunPcaResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="RunPcaResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="RunPcaResults.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="RunPcaResults.html#numberOfPCs">numberOfPCs</a></li><li data-type='method' style='display: none;'><a href="RunPcaResults.html#principalComponents">principalComponents</a></li><li data-type='method' style='display: none;'><a href="RunPcaResults.html#rotation">rotation</a></li><li data-type='method' style='display: none;'><a href="RunPcaResults.html#totalVariance">totalVariance</a></li><li data-type='method' style='display: none;'><a href="RunPcaResults.html#varianceExplained">varianceExplained</a></li></ul></li><li><a href="ScoreMarkersResults.html">ScoreMarkersResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#auc">auc</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#cohensD">cohensD</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#deltaDetected">deltaDetected</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#deltaMean">deltaMean</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#detected">detected</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#mean">mean</a></li><li data-type='method' style='display: none;'><a href="ScoreMarkersResults.html#numberOfGroups">numberOfGroups</a></li></ul></li><li><a href="ScranMatrix.html">ScranMatrix</a><ul class='methods'><li data-type='method' style='display: none;'><a href="ScranMatrix.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#column">column</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#free">free</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#isSparse">isSparse</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#numberOfColumns">numberOfColumns</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#numberOfRows">numberOfRows</a></li><li data-type='method' style='display: none;'><a href="ScranMatrix.html#row">row</a></li></ul></li><li><a href="SuggestAdtQcFiltersResults.html">SuggestAdtQcFiltersResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SuggestAdtQcFiltersResults.html#detected">detected</a></li><li data-type='method' style='display: none;'><a href="SuggestAdtQcFiltersResults.html#filter">filter</a></li><li data-type='method' style='display: none;'><a href="SuggestAdtQcFiltersResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="SuggestAdtQcFiltersResults.html#isBlocked">isBlocked</a></li><li data-type='method' style='display: none;'><a href="SuggestAdtQcFiltersResults.html#numberOfBlocks">numberOfBlocks</a></li><li data-type='method' style='display: none;'><a href="SuggestAdtQcFiltersResults.html#numberOfSubsets">numberOfSubsets</a></li><li data-type='method' style='display: none;'><a href="SuggestAdtQcFiltersResults.html#subsetSum">subsetSum</a></li></ul></li><li><a href="SuggestCrisprQcFiltersResults.html">SuggestCrisprQcFiltersResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SuggestCrisprQcFiltersResults.html#filter">filter</a></li><li data-type='method' style='display: none;'><a href="SuggestCrisprQcFiltersResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="SuggestCrisprQcFiltersResults.html#maxValue">maxValue</a></li><li data-type='method' style='display: none;'><a href="SuggestCrisprQcFiltersResults.html#numberOfBlocks">numberOfBlocks</a></li></ul></li><li><a href="SuggestRnaQcFiltersResults.html">SuggestRnaQcFiltersResults</a><ul class='methods'><li data-type='method' style='display: none;'><a href="SuggestRnaQcFiltersResults.html#detected">detected</a></li><li data-type='method' style='display: none;'><a href="SuggestRnaQcFiltersResults.html#filter">filter</a></li><li data-type='method' style='display: none;'><a href="SuggestRnaQcFiltersResults.html#free">free</a></li><li data-type='method' style='display: none;'><a href="SuggestRnaQcFiltersResults.html#isBlocked">isBlocked</a></li><li data-type='method' style='display: none;'><a href="SuggestRnaQcFiltersResults.html#numberOfBlocks">numberOfBlocks</a></li><li data-type='method' style='display: none;'><a href="SuggestRnaQcFiltersResults.html#numberOfSubsets">numberOfSubsets</a></li><li data-type='method' style='display: none;'><a href="SuggestRnaQcFiltersResults.html#subsetProportion">subsetProportion</a></li><li data-type='method' style='display: none;'><a href="SuggestRnaQcFiltersResults.html#sum">sum</a></li></ul></li><li><a href="TrainedLabelCellsReference.html">TrainedLabelCellsReference</a><ul class='methods'><li data-type='method' style='display: none;'><a href="TrainedLabelCellsReference.html#free">free</a></li><li data-type='method' style='display: none;'><a href="TrainedLabelCellsReference.html#numberOfFeatures">numberOfFeatures</a></li><li data-type='method' style='display: none;'><a href="TrainedLabelCellsReference.html#numberOfLabels">numberOfLabels</a></li></ul></li><li><a href="TsneStatus.html">TsneStatus</a><ul class='methods'><li data-type='method' style='display: none;'><a href="TsneStatus.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="TsneStatus.html#extractCoordinates">extractCoordinates</a></li><li data-type='method' style='display: none;'><a href="TsneStatus.html#free">free</a></li><li data-type='method' style='display: none;'><a href="TsneStatus.html#iterations">iterations</a></li><li data-type='method' style='display: none;'><a href="TsneStatus.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="TsneStatus.html#run">run</a></li></ul></li><li><a href="UmapStatus.html">UmapStatus</a><ul class='methods'><li data-type='method' style='display: none;'><a href="UmapStatus.html#clone">clone</a></li><li data-type='method' style='display: none;'><a href="UmapStatus.html#currentEpoch">currentEpoch</a></li><li data-type='method' style='display: none;'><a href="UmapStatus.html#extractCoordinates">extractCoordinates</a></li><li data-type='method' style='display: none;'><a href="UmapStatus.html#free">free</a></li><li data-type='method' style='display: none;'><a href="UmapStatus.html#numberOfCells">numberOfCells</a></li><li data-type='method' style='display: none;'><a href="UmapStatus.html#run">run</a></li><li data-type='method' style='display: none;'><a href="UmapStatus.html#totalEpochs">totalEpochs</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#aggregateAcrossCells">aggregateAcrossCells</a></li><li><a href="global.html#buildNeighborSearchIndex">buildNeighborSearchIndex</a></li><li><a href="global.html#buildSnnGraph">buildSnnGraph</a></li><li><a href="global.html#cbind">cbind</a></li><li><a href="global.html#cbindWithNames">cbindWithNames</a></li><li><a href="global.html#centerSizeFactors">centerSizeFactors</a></li><li><a href="global.html#chooseHvgs">chooseHvgs</a></li><li><a href="global.html#chooseTemporaryPath">chooseTemporaryPath</a></li><li><a href="global.html#chooseTopMarkers">chooseTopMarkers</a></li><li><a href="global.html#clusterGraph">clusterGraph</a></li><li><a href="global.html#clusterKmeans">clusterKmeans</a></li><li><a href="global.html#columnSums">columnSums</a></li><li><a href="global.html#computeClrm1Factors">computeClrm1Factors</a></li><li><a href="global.html#convertToFactor">convertToFactor</a></li><li><a href="global.html#createBigUint64WasmArray">createBigUint64WasmArray</a></li><li><a href="global.html#createBlock">createBlock</a></li><li><a href="global.html#createFloat32WasmArray">createFloat32WasmArray</a></li><li><a href="global.html#createFloat64WasmArray">createFloat64WasmArray</a></li><li><a href="global.html#createInt32WasmArray">createInt32WasmArray</a></li><li><a href="global.html#createNewHdf5File">createNewHdf5File</a></li><li><a href="global.html#createUint8WasmArray">createUint8WasmArray</a></li><li><a href="global.html#delayedArithmetic">delayedArithmetic</a></li><li><a href="global.html#delayedMath">delayedMath</a></li><li><a href="global.html#dropUnusedLevels">dropUnusedLevels</a></li><li><a href="global.html#emptySuggestAdtQcFiltersResults">emptySuggestAdtQcFiltersResults</a></li><li><a href="global.html#emptySuggestCrisprQcFiltersResults">emptySuggestCrisprQcFiltersResults</a></li><li><a href="global.html#emptySuggestRnaQcFiltersResults">emptySuggestRnaQcFiltersResults</a></li><li><a href="global.html#existsFile">existsFile</a></li><li><a href="global.html#extractHdf5MatrixDetails">extractHdf5MatrixDetails</a></li><li><a href="global.html#extractHdf5ObjectNames">extractHdf5ObjectNames</a></li><li><a href="global.html#extractMatrixMarketDimensions">extractMatrixMarketDimensions</a></li><li><a href="global.html#filterCells">filterCells</a></li><li><a href="global.html#findMaxStringLength">findMaxStringLength</a></li><li><a href="global.html#findNearestNeighbors">findNearestNeighbors</a></li><li><a href="global.html#free">free</a></li><li><a href="global.html#guessFeatures">guessFeatures</a></li><li><a href="global.html#heapSize">heapSize</a></li><li><a href="global.html#hypergeometricTest">hypergeometricTest</a></li><li><a href="global.html#initialize">initialize</a></li><li><a href="global.html#initializeDenseMatrixFromDenseArray">initializeDenseMatrixFromDenseArray</a></li><li><a href="global.html#initializeMatrixFromHdf5">initializeMatrixFromHdf5</a></li><li><a href="global.html#initializeMatrixFromHdf5Dataset">initializeMatrixFromHdf5Dataset</a></li><li><a href="global.html#initializeSparseMatrixFromDenseArray">initializeSparseMatrixFromDenseArray</a></li><li><a href="global.html#initializeSparseMatrixFromHdf5Group">initializeSparseMatrixFromHdf5Group</a></li><li><a href="global.html#initializeSparseMatrixFromMatrixMarket">initializeSparseMatrixFromMatrixMarket</a></li><li><a href="global.html#initializeSparseMatrixFromRds">initializeSparseMatrixFromRds</a></li><li><a href="global.html#initializeSparseMatrixFromSparseArrays">initializeSparseMatrixFromSparseArrays</a></li><li><a href="global.html#initializeTsne">initializeTsne</a></li><li><a href="global.html#initializeUmap">initializeUmap</a></li><li><a href="global.html#integrateLabelCells">integrateLabelCells</a></li><li><a href="global.html#integrateLabelCellsReferences">integrateLabelCellsReferences</a></li><li><a href="global.html#labelCells">labelCells</a></li><li><a href="global.html#loadHdf5Dataset">loadHdf5Dataset</a></li><li><a href="global.html#loadLabelCellsReferenceFromBuffers">loadLabelCellsReferenceFromBuffers</a></li><li><a href="global.html#maximumThreads">maximumThreads</a></li><li><a href="global.html#mnnCorrect">mnnCorrect</a></li><li><a href="global.html#modelGeneVariances">modelGeneVariances</a></li><li><a href="global.html#normalizeCounts">normalizeCounts</a></li><li><a href="global.html#perCellAdtQcMetrics">perCellAdtQcMetrics</a></li><li><a href="global.html#perCellCrisprQcMetrics">perCellCrisprQcMetrics</a></li><li><a href="global.html#perCellRnaQcMetrics">perCellRnaQcMetrics</a></li><li><a href="global.html#perplexityToNeighbors">perplexityToNeighbors</a></li><li><a href="global.html#possibleCopy">possibleCopy</a></li><li><a href="global.html#rbind">rbind</a></li><li><a href="global.html#readFile">readFile</a></li><li><a href="global.html#readRds">readRds</a></li><li><a href="global.html#realizeFile">realizeFile</a></li><li><a href="global.html#remapGeneSets">remapGeneSets</a></li><li><a href="global.html#removeFile">removeFile</a></li><li><a href="global.html#resetLevels">resetLevels</a></li><li><a href="global.html#rowSums">rowSums</a></li><li><a href="global.html#runPca">runPca</a></li><li><a href="global.html#runTsne">runTsne</a></li><li><a href="global.html#runUmap">runUmap</a></li><li><a href="global.html#scaleByNeighbors">scaleByNeighbors</a></li><li><a href="global.html#scoreGsdecon">scoreGsdecon</a></li><li><a href="global.html#scoreMarkers">scoreMarkers</a></li><li><a href="global.html#splitRows">splitRows</a></li><li><a href="global.html#subsetColumns">subsetColumns</a></li><li><a href="global.html#subsetFactor">subsetFactor</a></li><li><a href="global.html#subsetRows">subsetRows</a></li><li><a href="global.html#suggestAdtQcFilters">suggestAdtQcFilters</a></li><li><a href="global.html#suggestCrisprQcFilters">suggestCrisprQcFilters</a></li><li><a href="global.html#suggestRnaQcFilters">suggestRnaQcFilters</a></li><li><a href="global.html#terminate">terminate</a></li><li><a href="global.html#testGeneSetEnrichment">testGeneSetEnrichment</a></li><li><a href="global.html#trainLabelCellsReference">trainLabelCellsReference</a></li><li><a href="global.html#transpose">transpose</a></li><li><a href="global.html#truncateNearestNeighbors">truncateNearestNeighbors</a></li><li><a href="global.html#wasmArraySpace">wasmArraySpace</a></li><li><a href="global.html#writeFile">writeFile</a></li><li><a href="global.html#writeSparseMatrixToHdf5">writeSparseMatrixToHdf5</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">labelCells.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import * as gc from "./gc.js";
import * as wasm from "./wasm.js";
import * as utils from "./utils.js";
import { ScranMatrix } from "./ScranMatrix.js";
import * as wa from "wasmarrays.js";
import * as init from "./initializeMatrixFromArrays.js";

/**************************************************
 **************************************************/

/**
 * Wrapper around a labelled reference dataset on the Wasm heap, typically produced by {@linkcode loadLabelCellsReferenceFromBuffers}.
 * @hideconstructor
 */
class LoadedLabelCellsReference {
    #id;
    #reference;

    constructor(id, raw) {
        this.#id = id;
        this.#reference = raw;
        return;
    }

    // Internal use only, not documented.
    get reference() {
        return this.#reference;
    }

    /**
     * @return {number} Number of samples in this dataset.
     */
    numberOfSamples() {
        return this.#reference.num_samples();
    }

    /**
     * @return {number} Number of features in this dataset.
     */
    numberOfFeatures() {
        return this.#reference.num_features();
    }

    /**
     * @return {number} Number of labels in this dataset.
     */
    numberOfLabels() {
        return this.#reference.num_labels();
    }

    /**
     * @return Frees the memory allocated on the Wasm heap for this object.
     * This invalidates this object and all references to it.
     */
    free() {
        if (this.#reference !== null) {
            gc.release(this.#id);
            this.#reference = null;
        }
    }
}

/**
 * Load a reference dataset for annotation in {@linkecode labelCells}.
 * The reference should be represented by several files, the contents of which are described in the [**singlepp_loaders** documentation](https://github.com/SingleR-inc/singlepp_loaders).
 * 
 * @param {Uint8Array|Uint8WasmArray} ranks - Buffer containing the Gzipped CSV file containing a matrix of ranks.
 * Each line corresponds to a sample and contains a comma-separated vector of ranks across all features.
 * All lines should contain the same number of entries.
 * This is effectively a row-major matrix where rows are samples and columns are features.
 * (Advanced users may note that this is transposed in C++.) 
 * @param {Uint8Array|Uint8WasmArray} markers - Buffer containing the Gzipped GMT file containing the markers for each pairwise comparison between labels.
 * For `markers`, the GMT format is a tab-separated file with possibly variable numbers of fields for each line.
 * Each line corresponds to a pairwise comparison between labels, defined by the first two fields.
 * The remaining fields should contain indices of marker features (referring to columns of `matrix`) that are upregulated in the first label when compared to the second.
 * Markers should be sorted in order of decreasing strength.
 * @param {Uint8Array|Uint8WasmArray} labels - Buffer containing the Gzipped text file containing the label for each sample.
 * Each line should contain an integer representing a particular label, from `[0, N)` where `N` is the number of unique labels.
 * The number of lines should be equal to the number of rows in `matrix`.
 * The actual names of the labels are usually held elsewhere.
 * 
 * @return {LoadedLabelCellsReference} Object containing the reference dataset.
 */
export function loadLabelCellsReferenceFromBuffers(ranks, markers, labels) {
    var output;
    var matbuf;
    var markbuf;
    var labbuf;

    try {
        matbuf = utils.wasmifyArray(ranks, "Uint8WasmArray");
        markbuf = utils.wasmifyArray(markers, "Uint8WasmArray");
        labbuf = utils.wasmifyArray(labels, "Uint8WasmArray");
        output = gc.call(
            module => module.load_singlepp_reference(labbuf.offset, labbuf.length, markbuf.offset, markbuf.length, matbuf.offset, matbuf.length),
            LoadedLabelCellsReference
        );

    } catch (e) {
        utils.free(output);
        throw e;

    } finally {
        utils.free(matbuf);
        utils.free(markbuf);
        utils.free(labbuf);
    }

    return output;
}

/**************************************************
 **************************************************/

/**
 * Wrapper around a built labelled reference dataset on the Wasm heap, typically produced by {@linkcode trainLabelCellsReference}.
 * @hideconstructor
 */
class TrainedLabelCellsReference {
    #id;
    #reference;

    constructor(id, raw, expected_features) {
        this.#id = id;
        this.#reference = raw;
        this.expectedNumberOfFeatures = expected_features;
        return;
    }

    // internal use only.
    get reference() {
        return this.#reference;
    }

    /**
     * @return {number} Number of shared features between the test and reference datasets.
     */
    numberOfFeatures() {
        return this.#reference.num_features();
    }

    /**
     * @return {number} Number of labels in this dataset.
     */
    numberOfLabels() {
        return this.#reference.num_labels();
    }

    /**
     * @return Frees the memory allocated on the Wasm heap for this object.
     * This invalidates this object and all references to it.
     */
    free() {
        if (this.#reference !== null) {
            gc.release(this.#id);
            this.#reference = null;
        }
    }
}

/**
 * @ignore
 */
export function intersectFeatures(testFeatures, referenceFeatures) { // exported only for testing purposes.
    let registry = new Map;

    for (var i = 0; i &lt; testFeatures.length; i++) {
        let id = testFeatures[i];
        if (id !== null &amp;&amp; !registry.has(id)) { // first hit gets the preference.
            registry.set(id, i);
        }
    }

    let tkeep = [], rkeep = [];
    for (var i = 0; i &lt; referenceFeatures.length; i++) {
        let id = referenceFeatures[i];
        if (id == null) {
            continue;
        }

        if (!Array.isArray(id)) {
            if (registry.has(id)) {
                tkeep.push(registry.get(id));
                registry.delete(id); // deleting to avoid a future match to the same ID, as the intersection must be unique in its first/second hits.
                rkeep.push(i);
            }

        } else { // otherwise, it's an array of multiple synonymous gene names.
            for (const xid of id) {
                if (registry.has(xid)) {
                    tkeep.push(registry.get(xid));
                    registry.delete(xid);
                    rkeep.push(i);
                    break;
                }
            }
        }
    }

    return { "test": tkeep, "reference": rkeep };
}

/**
 * Train a reference dataset for annotation in {@linkcode labelCells}.
 * The build process involves harmonizing the identities of the features available in the test dataset compared to the reference.
 * Specifically, a feature must be present in both datasets in order to be retained. 
 * Of those features in the intersection, only the `top` markers from each pairwise comparison are ultimately used for classification.
 *
 * Needless to say, `testFeatures` should match up to the rows of the {@linkplain ScranMatrix} that is actually used for annotation in {@linkcode labelCells}.
 *
 * @param {Array} testFeatures - An array of feature identifiers (usually strings) of length equal to the number of rows in the test matrix.
 * Each entry should contain the identifier for the corresponding row of the test matrix.
 * Any `null` entries are considered to be incomparable.
 * @param {LoadedLabelCellsReference} loadedReference - A reference dataset, typically loaded with {@linkcode loadLabelCellsReferenceFromBuffers}.
 * @param {Array} referenceFeatures - An array of feature identifiers (usually strings) of length equal to the number of features in `reference`.
 * Each entry may also be an array of synonymous identifiers, in which case the first identifier that matches to an entry of `features` is used.
 * Contents of `referenceFeatures` are expected to exhibit some overlap with identifiers in `testFeatures`.
 * Any `null` entries are considered to be incomparable.
 * If multiple entries of `referenceFeatures` match to the same feature in `features`, only the first matching entry is used and the rest are ignored.
 * @param {object} [options={}] - Optional parameters.
 * @param {number} [options.top=20] - Number of top marker features to use.
 * These features are taken from each pairwise comparison between labels.
 * @param {?number} [options.numberOfThreads=null] - Number of threads to use.
 * If `null`, defaults to {@linkcode maximumThreads}.
 *
 * @return {TrainedLabelCellsReference} Object containing the built reference dataset.
 */
export function trainLabelCellsReference(testFeatures, loadedReference, referenceFeatures, options = {}) {
    const { top = 20, numberOfThreads = null, ...others } = options;
    utils.checkOtherOptions(others);

    var test_id_buffer;
    var ref_id_buffer;
    var output;
    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);

    if (referenceFeatures.length != loadedReference.numberOfFeatures()) {
        throw new Error("length of 'referenceFeatures' should be equal to the number of features in 'loadedReference'");
    }
    const intersection = intersectFeatures(testFeatures, referenceFeatures);

    try {
        test_id_buffer = utils.wasmifyArray(intersection.test, "Int32WasmArray");
        ref_id_buffer = utils.wasmifyArray(intersection.reference, "Int32WasmArray");
        output = gc.call(
            module => module.train_singlepp_reference(
                test_id_buffer.length,
                test_id_buffer.offset,
                ref_id_buffer.offset,
                loadedReference.reference,
                top,
                nthreads
            ),
            TrainedLabelCellsReference,
            testFeatures.length
        );

    } catch (e) {
        utils.free(output);
        throw e;

    } finally {
        utils.free(test_id_buffer);
        utils.free(ref_id_buffer);
    }

    return output;
}

/**************************************************
 **************************************************/

/**
 * Wrapper around the cell labelling results on the Wasm heap, typically produced by {@linkcode labelCells}.
 * @hideconstructor
 */
class LabelCellsResults {
    #id;
    #results;

    constructor(id, raw) {
        this.#id = id;
        this.#results = raw;
        return;
    }

    /**
     * @return {number} Number of labels used in {@linkcode labelCells}.
     */
    numberOfLabels() {
        return this.#results.num_labels();
    }

    /**
     * @return {number} Number of cells that were labelled.
     */
    numberOfCells() {
        return this.#results.num_samples();
    }

    /**
     * @param {object} [options={}] - Optional parameters.
     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.
     * @return {Int32Array|Int32WasmArray} Array of length equal to the number of cells,
     * containing the index of the best label for each cell.
     */
    predicted(options = {}) {
        const { copy = true, ...others } = options;
        utils.checkOtherOptions(others);
        return utils.possibleCopy(this.#results.best(), copy);
    }

    /**
     * @param {number} i - Index of the cell of interest.
     * @param {object} [options={}] - Optional parameters.
     * @param {boolean} [options.asTypedArray=true] - Whether to return a Float64Array.
     * If `false`, a Float64WasmArray is returned instead.
     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.
     * This should have the same length as the {@linkcode LabelCellsResults#numberOfLabels numberOfLabels}.
     *
     * @return {Float64Array|Float64WasmArray} Array containing the scores for this cell across all labels.
     * If `buffer` is supplied, the function returns `buffer` if `asTypedArray = false`, or a view on `buffer` if `asTypedArray = true`.
     */
    scoreForCell(i, options = {}) {
        let { asTypedArray = true, buffer = null, ...others } = options;
        utils.checkOtherOptions(others);

        let tmp = null;
        try {
            if (buffer == null) {
                tmp = utils.createFloat64WasmArray(this.#results.num_labels());
                buffer = tmp;
            }
            this.#results.score_for_sample(i, buffer.offset);
        } catch (e) {
            utils.free(tmp);
            throw e;
        }

        return utils.toTypedArray(buffer, tmp == null, asTypedArray);
    }

    /**
     * @param {number} i - Index of the label of interest.
     * @param {object} [options={}] - Optional parameters.
     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.
     * Only used if `buffer` is not supplied.
     * @return {Float64Array|Float64WasmArray} Array containing the scores across all cells for this label.
     */
    scoreForLabel(i, options = {}) {
        const { copy = true, ...others } = options;
        utils.checkOtherOptions(others);
        return utils.possibleCopy(this.#results.score_for_label(i), copy);
    }

    /**
     * @param {object} [options={}] - Optional parameters.
     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.
     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of cells,
     * containing the difference in scores between the best and second-best labels.
     */
    delta(options = {}) {
        const { copy = true, ...others } = options;
        utils.checkOtherOptions(others);
        return utils.possibleCopy(this.#results.delta(), copy);
    }

    /**
     * @return Frees the memory allocated on the Wasm heap for this object.
     * This invalidates this object and all references to it.
     */
    free() {
        if (this.#results !== null) {
            gc.release(this.#id);
            this.#results = null;
        }
    }
}

/**
 * Label cells based on similarity in expression to a reference dataset.
 * This uses the [**SingleR** algorithm](https://github.com/SingleR-inc/singlepp) for cell type annotation.
 *
 * @param {ScranMatrix|Float64WasmArray} x - The count matrix, or log-normalized matrix, containing features in the rows and cells in the columns.
 * If a Float64WasmArray is supplied, it is assumed to contain a column-major dense matrix.
 * @param {BuildLabelledReferenceResults} reference - A built reference dataset, typically generated by {@linkcode buildLabelledReference}.
 * @param {object} [options={}] - Optional parameters.
 * @param {?number} [options.numberOfFeatures=null] - Number of features, used when `x` is a Float64WasmArray.
 * @param {?number} [options.numberOfCells=null] - Number of cells, used when `x` is a Float64WasmArray.
 * @param {number} [options.quantile=0.8] - Quantile on the correlations to use to compute the score for each label.
 * @param {?number} [options.numberOfThreads=null] - Number of threads to use.
 * If `null`, defaults to {@linkcode maximumThreads}.
 *
 * @return {LabelCellsResults} Labelling results for each cell in `x`.
 */
export function labelCells(x, reference, options = {}) {
    const { numberOfFeatures = null, numberOfCells = null, quantile = 0.8, numberOfThreads = null, ...others } = options;
    utils.checkOtherOptions(others);

    var output = null;
    var matbuf;
    var tempmat;
    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);

    try {
        let target;
        if (x instanceof ScranMatrix) {
            target = x.matrix;
        } else if (x instanceof wa.Float64WasmArray) {
            tempmat = init.initializeDenseMatrixFromDenseArray(numberOfFeatures, numberOfCells, x, { forceInteger: false });
            target = tempmat.matrix;
        } else {
            throw new Error("unknown type for 'x'");
        }

        if (target.nrow() != reference.expectedNumberOfFeatures) {
            throw new Error("number of rows in 'x' should be equal to length of 'features' used to build 'reference'");
        }

        output = gc.call(
            module => module.run_singlepp(target, reference.reference, quantile, nthreads),
            LabelCellsResults
        );
    } finally {
        utils.free(matbuf);
        utils.free(tempmat);
    }

    return output;
}

/**************************************************
 **************************************************/

/**
 * Wrapper around integrated reference datasets on the Wasm heap, typically produced by {@linkcode integrateLabelledReferences}.
 * @hideconstructor
 */
class IntegratedLabelCellsReferences {
    #id;
    #integrated;

    constructor(id, raw, expected_features) {
        this.#id = id;
        this.#integrated = raw;
        this.expectedNumberOfFeatures = expected_features;
        return;
    }

    // Internal use only, not documented.
    get integrated() {
        return this.#integrated;
    }

    /**
     * @return {number} Number of reference datasets.
     */
    numberOfReferences() {
        return this.#integrated.num_references();
    }

    /**
     * @return Frees the memory allocated on the Wasm heap for this object.
     * This invalidates this object and all references to it.
     */
    free() {
        if (this.#integrated !== null) {
            gc.release(this.#id);
            this.#integrated = null;
        }
    }
}

/**
 * Prepare a classifier that integrates multiple reference datasets.
 * This allows users to choose the best label for a test cell based on its classifications in multiple references.
 *
 * @param {Array} testFeatures - An array of feature identifiers (usually strings) of length equal to the number of rows in the test matrix.
 * Each entry should contain a single identifier for the corresponding row of the test matrix.
 * Any `null` entries are considered to be incomparable.
 * If any entries are duplicated, only the first occurrence is used and the rest are ignored.
 * @param {Array} loadedReferences - Array of {@linkplain LoadedLabelCellsReference} objects, typically created with {@linkcode loadLabelCellsReferenceFromBuffers}.
 * @param {Array} referenceFeatures - Array of length equal to `loadedReferences`, 
 * containing arrays of feature identifiers (usually strings) of length equal to the number of features the corresponding entry of `loadedReferences`.
 * Each entry may also be an array of synonymous identifiers, in which case the first identifier that matches to an entry of `testFeatures` is used.
 * Contents of `referenceFeatures` are expected to exhibit some overlap with identifiers in `testFeatures`.
 * Any `null` entries are considered to be incomparable.
 * If multiple entries of `referenceFeatures` match to the same feature in `testFeatures`, only the first matching entry is used and the rest are ignored.
 * @param {Array} trainedReferences - Array of {@linkplain TrainedLabelCellsReference} objects, typically generated by calling {@linkcode trainLabelCellsReference} 
 * on the same `testFeatures` and the corresponding entries of `loadedReferences` and `referenceFeatures`.
 * This should have length equal to that of `loadedReferences`.
 * @param {object} [options={}] - Optional parameters.
 * @param {?number} [options.numberOfThreads=null] - Number of threads to use.
 * If `null`, defaults to {@linkcode maximumThreads}.
 *
 * @return {IntegratedLabelCellsReference} Object containing the integrated references.
 */
export function integrateLabelCellsReferences(testFeatures, loadedReferences, referenceFeatures, trainedReferences, options = {}) {
    const { numberOfThreads = null, ...others } = options;
    utils.checkOtherOptions(others);

    let interlen_arr;
    let test_id_arr = [];
    let test_id_ptr_arr;
    let ref_id_arr = [];
    let ref_id_ptr_arr;
    let loaded_arr;
    let trained_arr;
    let output;
    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);

    // Checking the inputs.
    let nrefs = loadedReferences.length;
    if (referenceFeatures.length != nrefs) {
        throw new Error("'loadedReferences' and 'referenceFeatures' should be of the same length");
    }
    if (trainedReferences.length != nrefs) {
        throw new Error("'loadedReferences' and 'trainedReferences' should be of the same length");
    }
    for (var i = 0; i &lt; nrefs; i++) {
        if (loadedReferences[i].numberOfFeatures() != referenceFeatures[i].length) {
            throw new Error("length of each 'referenceFeatures' should be equal to the number of features in the corresponding 'loadedReferences'");
        }
    }

    try {
        for (var i = 0; i &lt; nrefs; i++) {
            const intersection = intersectFeatures(testFeatures, referenceFeatures[i]);
            test_id_arr.push(utils.wasmifyArray(intersection.test, "Int32WasmArray"));
            ref_id_arr.push(utils.wasmifyArray(intersection.reference, "Int32WasmArray"));
        }

        loaded_arr = utils.createBigUint64WasmArray(nrefs);
        trained_arr = utils.createBigUint64WasmArray(nrefs);
        test_id_ptr_arr = utils.createBigUint64WasmArray(nrefs);
        ref_id_ptr_arr = utils.createBigUint64WasmArray(nrefs);
        interlen_arr = utils.createInt32WasmArray(nrefs);
        {
            let la = loaded_arr.array();
            let ta = trained_arr.array(); 
            let tia = test_id_ptr_arr.array();
            let ria = ref_id_ptr_arr.array();
            let ia = interlen_arr.array();
            for (var i = 0; i &lt; nrefs; i++) {
                la[i] = BigInt(loadedReferences[i].reference.$$.ptr);
                ta[i] = BigInt(trainedReferences[i].reference.$$.ptr);
                tia[i] = BigInt(test_id_arr[i].offset);
                ria[i] = BigInt(ref_id_arr[i].offset);
                ia[i] = test_id_arr[i].length;
            }
        }

        output = gc.call(
            module => module.integrate_singlepp_references(
                nrefs,
                interlen_arr.offset,
                test_id_ptr_arr.offset,
                ref_id_ptr_arr.offset,
                loaded_arr.offset,
                trained_arr.offset,
                nthreads
            ),
            IntegratedLabelCellsReferences,
            testFeatures.length
        );

    } catch (e) {
        utils.free(output);
        throw e;

    } finally {
        for (const x of test_id_arr) {
            utils.free(x);
        }
        for (const x of ref_id_arr) {
            utils.free(x);
        }
        utils.free(test_id_ptr_arr);
        utils.free(ref_id_ptr_arr);
        utils.free(loaded_arr);
        utils.free(trained_arr);
    }

    return output;
}

/**************************************************
 **************************************************/

/**
 * Wrapper around the integrated cell labelling results on the Wasm heap, typically produced by {@linkcode integrateLabelCells}.
 * @hideconstructor
 */
class IntegrateLabelCellsResults {
    #id
    #results;

    constructor(id, raw) {
        this.#id = id;
        this.#results = raw;
        return;
    }

    /**
     * @return {number} Number of labels used in {@linkcode integratedLabelCells}.
     */
    numberOfReferences() {
        return this.#results.num_references();
    }

    /**
     * @return {number} Number of cells that were labelled.
     */
    numberOfCells() {
        return this.#results.num_samples();
    }

    /**
     * @param {object} [options={}] - Optional parameters.
     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.
     *
     * @return {Int32Array|Int32WasmArray} Array of length equal to the number of cells,
     * containing the index of the best reference for each cell.
     */
    predicted(options = {}) {
        const { copy = true, ...others } = options;
        utils.checkOtherOptions(others);
        return utils.possibleCopy(this.#results.best(), copy);
    }

    /**
     * @param {number} i - Index of the cell of interest.
     * @param {object} [options={}] - Optional parameters.
     * @param {boolean} [options.asTypedArray=true] - Whether to return a Float64Array.
     * If `false`, a Float64WasmArray is returned instead.
     * @param {?Float64WasmArray} [options.buffer=null] - Buffer in which to store the output.
     * This should have the same length as the {@linkcode IntegrateLabelCellsResults#numberOfReferences numberOfReferences}.
     *
     * @return {Float64Array|Float64WasmArray} Array containing the scores for this cell across all labels.
     * If `buffer` is supplied, the function returns `buffer` if `asTypedArray = false`, or a view on `buffer` if `asTypedArray = true`.
     */
    scoreForCell(i, options = {}) {
        let { asTypedArray = true, buffer = null, ...others } = options;
        utils.checkOtherOptions(others);

        let tmp;
        try {
            if (buffer == null) {
                tmp = utils.createFloat64WasmArray(this.#results.num_references());
                buffer = tmp;
            }
            this.#results.score_for_sample(i, buffer.offset);
        } catch (e) {
            utils.free(tmp);
            throw e;
        }
        return utils.toTypedArray(buffer, tmp == null, asTypedArray);
    }

    /**
     * @param {number} i - Index of the reference of interest.
     * @param {object} [options={}] - Optional parameters.
     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.
     *
     * @return {Float64Array|Float64WasmArray} Array containing the scores across all cells for this label.
     */
    scoreForReference(i, options = {}) {
        const { copy = true, ...others } = options;
        utils.checkOtherOptions(others);
        return utils.possibleCopy(this.#results.score_for_reference(i), copy);
    }

    /**
     * @param {object} [options={}] - Optional parameters.
     * @param {boolean|string} [options.copy=true] - Copying mode, see {@linkcode possibleCopy} for details.
     *
     * @return {Float64Array|Float64WasmArray} Array of length equal to the number of cells,
     * containing the difference in scores between the best and second-best references.
     */
    delta(options = {}) {
        const { copy = true, ...others } = options;
        utils.checkOtherOptions(others);
        return utils.possibleCopy(this.#results.delta(), copy);
    }

    /**
     * @return Frees the memory allocated on the Wasm heap for this object.
     * This invalidates this object and all references to it.
     */
    free() {
        if (this.#results !== null) {
            gc.release(this.#id);
            this.#results = null;
        }
    }
}

/**
 * Integrate cell labels across multiple reference datasets.
 *
 * @param {ScranMatrix|Float64WasmArray} x - The count matrix, or log-normalized matrix, containing features in the rows and cells in the columns.
 * If a Float64WasmArray is supplied, it is assumed to contain a column-major dense matrix.
 * @param {IntegratedLabelCellsReferences} integrated - An integrated set of reference datasets, typically generated by {@linkcode integrateLabelCellsReferences}.
 * @param {Array} assigned - An array of length equal to the number of references in `integrated`.
 * This should contain the result of classification of `x` with each individual reference via {@linkcode labelCells}.
 * Each element should be a {@linkplain LabelCellsResults} object; or an Array, TypedArray or Int32WasmArray of length equal to the number of cells in `x`.
 * @param {object} [options={}] - Optional parameters.
 * @param {?number} [options.numberOfFeatures=null] - Number of features, used when `x` is a Float64WasmArray.
 * @param {?number} [options.numberOfCells=null] - Number of cells, used when `x` is a Float64WasmArray.
 * @param {number} [options.quantile=0.8] - Quantile on the correlations to use to compute the score for each label.
 * @param {?number} [options.numberOfThreads=null] - Number of threads to use.
 * If `null`, defaults to {@linkcode maximumThreads}.
 *
 * @return {IntegrateLabelCellsResults} Integrated labelling results for each cell in `x`.
 */
export function integrateLabelCells(x, assigned, integrated, options = {}) {
    const { numberOfFeatures = null, numberOfCells = null, quantile = 0.8, numberOfThreads = null, ...others } = options;
    utils.checkOtherOptions(others);

    let nrefs = integrated.numberOfReferences();
    if (assigned.length != nrefs) {
        throw new Error("length of 'assigned' should be equal to the number of references in 'integrated'");
    }

    let output;
    var matbuf;
    var tempmat;
    let assigned_ptrs;
    let assigned_arrs = new Array(nrefs);
    let nthreads = utils.chooseNumberOfThreads(numberOfThreads);

    try {
        let target;
        if (x instanceof ScranMatrix) {
            target = x.matrix;
        } else if (x instanceof wa.Float64WasmArray) {
            tempmat = init.initializeScranMatrixFromDenseArray(numberOfFeatures, numberOfCells, x, { sparse: false, forceInteger: false });
            target = tempmat.matrix;
        } else {
            throw new Error("unknown type for 'x'");
        }
        if (target.nrow() != integrated.expectedNumberOfFeatures) {
            throw new Error("number of rows in 'x' should be equal to length of 'features' used to build 'reference'");
        }

        assigned_ptrs = utils.createBigUint64WasmArray(nrefs);
        let assigned_ptr_arr = assigned_ptrs.array();
        for (var i = 0; i &lt; assigned.length; i++) {
            let current = assigned[i];
            if (current instanceof LabelCellsResults) {
                current = current.predicted({ copy: "view" });
            }
            if (current.length != x.numberOfColumns()) {
                throw new Error("length of each element in 'assigned' should be equal to number of columns in 'x'");
            }
            assigned_arrs[i] = utils.wasmifyArray(current, "Int32WasmArray");
            assigned_ptr_arr[i] = BigInt(assigned_arrs[i].offset);
        }
    
        output = gc.call(
            module => module.integrate_singlepp(
                target,
                assigned_ptrs.offset,
                integrated.integrated,
                quantile,
                nthreads
            ),
            IntegrateLabelCellsResults
        );

    } catch (e) {
        utils.free(output);
        throw e;

    } finally{
        utils.free(assigned_ptrs);
        for (const x of assigned_arrs) {
            utils.free(x);
        }
        utils.free(matbuf);
        utils.free(tempmat);
    }

    return output;
}
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on Fri Aug 01 2025 18:02:43 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
