#include <emscripten/bind.h>

#include "NumericMatrix.h"
#include "utils.h"
#include "PerCellQCMetrics_Results.h"
#include "parallel.h"

#include "scran/quality_control/PerCellRnaQcFilters.hpp"

#include <vector>
#include <algorithm>
#include <cstdint>

/**
 * @file per_cell_qc_filters.cpp
 *
 * @brief Define filters on the QC metrics to remove low-quality cells.
 */

/**
 * @brief Javascript-visible wrapper around `scran::PerCellQCFilters::Results`.
 */
struct PerCellQCFilters_Results {
    /** 
     * @cond
     */
    typedef scran::PerCellQCFilters::Results<> Store;

    PerCellQCFilters_Results(Store s) : store(std::move(s)) {}

    Store store;
    /** 
     * @endcond
     */

    PerCellQCFilters_Results(int num_genes, int num_subsets, int num_blocks) {
        store.filter_by_sums.resize(num_genes);
        store.filter_by_detected.resize(num_genes);
        store.filter_by_subset_proportions.resize(num_subsets);
        for (int s = 0; s < num_subsets; ++s) {
            store.filter_by_subset_proportions[s].resize(num_genes);
        }
        store.overall_filter.resize(num_genes);

        store.thresholds.sums.resize(num_blocks);
        store.thresholds.detected.resize(num_blocks);
        store.thresholds.subset_proportions.resize(num_subsets);
        for (int s = 0; s < num_subsets; ++s) {
            store.thresholds.subset_proportions[s].resize(num_blocks);
        }
    }

    /**
     * @return `UInt8Array` view specifying whether a cell was discarded because its total counts were too low.
     */
    emscripten::val discard_sums() const {
        return emscripten::val(emscripten::typed_memory_view(store.filter_by_sums.size(), store.filter_by_sums.data()));
    }

    /**
     * @return `UInt8Array` view specifying whether a cell was discarded because its number of detected features were too low.
     */
    emscripten::val discard_detected() const {
        return emscripten::val(emscripten::typed_memory_view(store.filter_by_detected.size(), store.filter_by_detected.data()));
    }

    /**
     * @param i Index of the feature subset of interest.
     * @return `UInt8Array` view specifying whether a cell was discarded because its proportion of counts in subset `i` was too high.
     */
    emscripten::val discard_proportions(int i) const {
        const auto& current = store.filter_by_subset_proportions[i];
        return emscripten::val(emscripten::typed_memory_view(current.size(), current.data()));
    }

    /**
     * @return `UInt8Array` view specifying whether a cell was discarded for any reason.
     */
    emscripten::val discard_overall() const {
        return emscripten::val(emscripten::typed_memory_view(store.overall_filter.size(), store.overall_filter.data()));
    }

    /**
     * @return `Float64Array` view containing the threshold applied on the total count (possibly for each block).
     */
    emscripten::val thresholds_sums() const {
        return emscripten::val(emscripten::typed_memory_view(store.thresholds.sums.size(), store.thresholds.sums.data()));
    }

    /**
     * @return `Float64Array` view containing the threshold applied on the number of detected genes (possibly for each block).
     */
    emscripten::val thresholds_detected() const {
        return emscripten::val(emscripten::typed_memory_view(store.thresholds.detected.size(), store.thresholds.detected.data()));
    }

    /**
     * @param i Index of the feature subset of interest.
     * @return `Float64Array` view containing the threshold applied on the subset proportions for subset `i` (possibly for each block).
     */
    emscripten::val thresholds_proportions(int i) const {
        return emscripten::val(emscripten::typed_memory_view(store.thresholds.subset_proportions[i].size(), store.thresholds.subset_proportions[i].data()));
    }

    /**
     * @return Number of feature subsets for which proportion filters were computed.
     */
    int num_subsets() const {
        return store.thresholds.subset_proportions.size();
    }
};

/**
 * Apply a typical filtering step on the per-cell QC metrics, by removing cells that have undesirable outlier values.
 *
 * @param metrics A `PerCellQCMetrics_Results` object, generated by a prior call to `per_cell_qc_metrics()`.
 * @param use_blocks Whether or not to compute the default filters within each block.
 * @param[in] blocks If `use_blocks = true`, offset to an array of `int32_t`s with `ncells` elements, containing the block assignment for each cell.
 * Block IDs should be consecutive and 0-based.
 * If `use_blocks = false`, this value is ignored.
 * @param nmads Number of MADs from the median, to use for defining outliers.
 *
 * @return A `PerCellQCFilters_Results` object that can be interrogated to obtain filter statistics.
 */
PerCellQCFilters_Results per_cell_qc_filters(PerCellQCMetrics_Results& metrics, bool use_blocks, uintptr_t blocks, double nmads) {
    scran::PerCellQCFilters qc;
    qc.set_nmads(nmads);

    const int32_t* bptr = NULL;
    if (use_blocks) {
        bptr = reinterpret_cast<const int32_t*>(blocks);
    }

    auto thresholds = qc.run_blocked(metrics.store, bptr);
    return PerCellQCFilters_Results(std::move(thresholds));
}

/**
 * @cond 
 */
EMSCRIPTEN_BINDINGS(per_cell_qc_filters) {
    emscripten::function("per_cell_qc_filters", &per_cell_qc_filters);

    emscripten::class_<PerCellQCFilters_Results>("PerCellQCFilters_Results")
        .constructor<int, int, int>()
        .function("thresholds_sums", &PerCellQCFilters_Results::thresholds_sums)
        .function("thresholds_detected", &PerCellQCFilters_Results::thresholds_detected)
        .function("thresholds_proportions", &PerCellQCFilters_Results::thresholds_proportions)
        .function("discard_sums", &PerCellQCFilters_Results::discard_sums)
        .function("discard_detected", &PerCellQCFilters_Results::discard_detected)
        .function("discard_proportions", &PerCellQCFilters_Results::discard_proportions)
        .function("discard_overall", &PerCellQCFilters_Results::discard_overall)
        .function("num_subsets", &PerCellQCFilters_Results::num_subsets)
        ;
}
/**
 * @endcond 
 */

